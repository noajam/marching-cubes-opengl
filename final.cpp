/*
 *  Noah James
 *  Final Project: Marching Cubes Terrain Generation
 *
 *  Key bindings:
 *  gG         Change grid resolution
 *  hH         Change space that grid occupies
 *  iI         Change the isovalue for computing the isosurface
 *  m          Switch between 3 surface generators (Function, Sphere, Terrain Noise)
 *  v          Toggle axes
 *  k          Toggle the grid line display
 *  f          Toggle wireframe
 *  xXyYzZ     Translate the displayed surface
 *  cC         Scale the displayed surface
 *  n          Switch between centered view and first person mode
 *  L          Stop light movement
 *  ;:         Slow down/speed up light movement
 *  o          Switch between gradient and textured views
 *  wasd       First person movement
 *  spacebar   First person move in positive Y direction
 *  left ctrl  First person move in negative Y direction
 *  Mouse      Change view angle      
 *  arrows     Change view angle
 *  PgDn/PgUp  Zoom in and out
 *  0          Reset view angle
 *  ESC        Exit
 */

#include "CSCIx239.h"
#include <glm/glm.hpp>
#include <glm/ext.hpp>
int mode = 0;                          //  Surface selection
int axes = 1;                          //  Axes
int move = 1;                          //  Moving light
int fp = 0;                            //  First person mode
float zh = 0.0;                        //  Light position
float ls = 7.5;                        //  Light movement speed
float th = 90.0, ph = 0.0;             //  View angles
int fov = 57;                          //  Field of view (for perspective)                     //  Light elevation
float asp = 1;                         //  Aspect ratio
float dim = 4;                         //  Size of world
int wireframe = 0;                     //  Wireframe mode
int gridProgram = 0;                   //  Shader for displaying grid
int march1 = 0;                        //  Shader without textures
int march2 = 0;                        //  Shader with textures
int mcProgram = 0;                     //  Shader for running marching cubes
float dx = 0.0, dy = 0.0, dz = 0.0;    // translation
float dph = 0.0, dth = 0.0, dps = 0.0; // rotation
float Scale = 1.0;                     // scale
float gridSpace = 2.0;                 // Length of one edge of grid volume
int gridSize = 5;                      // Grid resolution
float cubeSize;                        // Distance from center of marching cube to any face
int displayGrid = 1;                   // Toggle grid display
float isovalue = 0.0;                  // Isovalue for marching cubes

float vertexOffsets[8 * 3]; // Marching cube offsets to all 8 vertices

using namespace glm;

// Camera vectors and variables
float deltaTime = 0.0f; // Time between current frame and last frame
float lastFrame = 0.0f; // Time of last frame
float lastX = 800.0, lastY = 600.0;
bool firstMouse = true;
vec3 cameraPos;
vec3 cameraFront;
vec3 cameraUp;

//
// Grid buffers
//
unsigned int vbo;
unsigned int vao;

unsigned int noiseTex;
unsigned int mountTex;
unsigned int edgeTex;
unsigned int triTex;

//
// Edge Table
//
int edgeTable[256] = {
    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
    0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
    0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
    0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
    0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
    0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
    0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
    0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
    0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
    0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
    0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
    0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
    0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
    0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
    0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
    0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
    0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
    0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
    0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
    0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
    0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
    0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
    0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
    0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0};

//
// Triangle Table
//
int triTable[256][16] =
    {{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},
     {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},
     {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},
     {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},
     {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},
     {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
     {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},
     {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},
     {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
     {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},
     {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},
     {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},
     {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},
     {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
     {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},
     {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},
     {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
     {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
     {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
     {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
     {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},
     {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
     {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
     {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
     {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},
     {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
     {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
     {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
     {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},
     {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
     {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
     {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},
     {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
     {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
     {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
     {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
     {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},
     {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
     {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
     {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},
     {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
     {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
     {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
     {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
     {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
     {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
     {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},
     {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
     {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
     {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
     {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
     {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},
     {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
     {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
     {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
     {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
     {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},
     {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
     {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
     {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
     {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},
     {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
     {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
     {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},
     {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
     {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
     {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
     {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
     {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},
     {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
     {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
     {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
     {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
     {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
     {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
     {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},
     {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
     {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
     {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
     {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
     {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
     {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
     {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
     {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
     {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},
     {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
     {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
     {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
     {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},
     {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
     {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
     {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
     {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},
     {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
     {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
     {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
     {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},
     {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
     {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
     {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
     {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},
     {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
     {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
     {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
     {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
     {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
     {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
     {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
     {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},
     {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
     {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
     {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
     {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},
     {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
     {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
     {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
     {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
     {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},
     {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
     {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
     {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
     {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},
     {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
     {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
     {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
     {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
     {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},
     {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
     {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
     {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
     {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
     {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
     {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},
     {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
     {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
     {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
     {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},
     {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
     {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
     {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
     {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},
     {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
     {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
     {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
     {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},
     {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
     {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
     {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
     {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
     {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
     {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
     {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
     {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
     {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},
     {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
     {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},
     {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
     {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
     {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
     {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
     {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},
     {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
     {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
     {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
     {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
     {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
     {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
     {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
     {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
     {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},
     {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
     {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},
     {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};

//
// Initialize marching cubes grid VBO
//
void initGridVBO(GLuint *vbo)
{
   if (!*vbo)
   {
      // Generate buffer name (a positive integer)
      glGenBuffers(1, vbo);
   }
   else
   {
      glDeleteBuffers(1, vbo);
      glGenBuffers(1, vbo);
   }

   cubeSize = gridSpace / (2 * gridSize);
   vertexOffsets[0] = -cubeSize; // -,-,-
   vertexOffsets[1] = -cubeSize;
   vertexOffsets[2] = -cubeSize;
   vertexOffsets[3] = cubeSize; // +,-,-
   vertexOffsets[4] = -cubeSize;
   vertexOffsets[5] = -cubeSize;
   vertexOffsets[6] = cubeSize; // +,+,-
   vertexOffsets[7] = cubeSize;
   vertexOffsets[8] = -cubeSize;
   vertexOffsets[9] = -cubeSize; // -,+,-
   vertexOffsets[10] = cubeSize;
   vertexOffsets[11] = -cubeSize;
   vertexOffsets[12] = -cubeSize; // -,-,+
   vertexOffsets[13] = -cubeSize;
   vertexOffsets[14] = cubeSize;
   vertexOffsets[15] = cubeSize; // +,-,+
   vertexOffsets[16] = -cubeSize;
   vertexOffsets[17] = cubeSize;
   vertexOffsets[18] = cubeSize; // +,+,+
   vertexOffsets[19] = cubeSize;
   vertexOffsets[20] = cubeSize;
   vertexOffsets[21] = -cubeSize; // -,+,+
   vertexOffsets[22] = cubeSize;
   vertexOffsets[23] = cubeSize;

   // Generate grid data
   float gridData[gridSize * gridSize * gridSize * 3];
   unsigned int count = 0;
   for (int i = 0; i < gridSize; i++)
   {
      for (int j = 0; j < gridSize; j++)
      {
         for (int k = 0; k < gridSize; k++)
         {
            // {x, y, z} coordinates, using
            gridData[count] = ((float)i * cubeSize * 2) + cubeSize - (gridSpace / 2);
            gridData[count + 1] = ((float)j * cubeSize * 2) + cubeSize - (gridSpace / 2);
            gridData[count + 2] = ((float)k * cubeSize * 2) + cubeSize - (gridSpace / 2);
            count += 3;
         }
      }
   }

   // Bind buffer and load data
   glBindBuffer(GL_ARRAY_BUFFER, *vbo);
   glBufferData(GL_ARRAY_BUFFER, sizeof(gridData), gridData, GL_STATIC_DRAW);

   // Unbind once done
   glBindBuffer(GL_ARRAY_BUFFER, 0);
   ErrCheck("Init VBO");
}

//
// Initialize marching cubes grid VAO
//
void initGridVAO(GLuint *vao, GLuint *vbo)
{
   if (!*vao)
   {
      // Generate VAO name (a positive integer)
      glGenVertexArrays(1, vao);
   }
   else
   {
      glDeleteVertexArrays(1, vao);
      glGenVertexArrays(1, vao);
   }

   // Create grid VAO to bind attribute array
   glBindVertexArray(*vao);

   // Bind VBO
   glBindBuffer(GL_ARRAY_BUFFER, *vbo);

   // Vertex
   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL);
   glEnableVertexAttribArray(0);

   //  Release VBO
   glBindBuffer(GL_ARRAY_BUFFER, 0);
   //  Release VAO
   glBindVertexArray(0);

   ErrCheck("Init VAO");
}

//
// Load Edge Table texture
//
void loadEdgeTable(GLuint *tex, int unit)
{
   glActiveTexture(unit);
   glGenTextures(1, tex);
   glBindTexture(GL_TEXTURE_2D, *tex);

   // Texture filtering
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   // Texture wrapping
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

   glTexImage2D(GL_TEXTURE_2D, 0, GL_R32I, 256, 1, 0, GL_RED_INTEGER, GL_INT, edgeTable);

   ErrCheck("loadEdgeTable");
}

//
// Load Triangle Table texture
//
void loadTriTable(GLuint *tex, int unit)
{
   glActiveTexture(unit);
   glGenTextures(1, tex);
   glBindTexture(GL_TEXTURE_2D, *tex);

   // Texture filtering
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
   // Texture wrapping
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

   glTexImage2D(GL_TEXTURE_2D, 0, GL_R32I, 16, 256, 0, GL_RED_INTEGER, GL_INT, triTable);

   ErrCheck("loadTriTable");
}

//
//  Refresh display
//
void display(GLFWwindow *window)
{
   //  Erase the window and the depth buffer
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   //  Enable Z-buffering in OpenGL
   glEnable(GL_DEPTH_TEST);

   if (!fp)
   {
      //  Eye position for perspective
      cameraPos.x = -2 * dim * sin(radians(th)) * cos(radians(ph));
      cameraPos.y = +2 * dim * sin(radians(ph));
      cameraPos.z = +2 * dim * cos(radians(th)) * cos(radians(ph));
      cameraFront.x = -cameraPos.x;
      cameraFront.y = -cameraPos.y;
      cameraFront.z = -cameraPos.z;
   }

   //    //  Lighting parameters
   float global[] = {0.1, 0.1, 0.1, 1.0};
   float ambient[] = {0.3, 0.3, 0.3, 1.0};
   float diffuse[] = {0.8, 0.8, 0.8, 1.0};
   float specular[] = {1.0, 1.0, 1.0, 1.0};
   float position[] = {0, 5 * cos(radians(zh)), 5 * sin(radians(zh)), 1.0};

#ifndef APPLE_GL4
   //  Set projection and view for fixed pipeline
   //  Set projection matrix
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   //  Perspective transformation
   gluPerspective(fov, asp, dim / 128, 128 * dim);
   //  Reset modelview
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   gluLookAt(cameraPos.x, cameraPos.y, cameraPos.z,
             cameraPos.x + cameraFront.x, cameraPos.y + cameraFront.y, cameraPos.z + cameraFront.z,
             0, cameraUp.y, 0);

   //  Draw axes using fixed pipeline (white)
   if (axes)
      Axes(3);
   //  Draw light position as white ball using fixed pipeline
   SetColor(1, 1, 1);
   Sphere(position[0], position[1], position[2], 0.1, 0, 8, 0);
#endif

   //  Enable shader
   glUseProgram(gridProgram);

   //  OpenGL 4: glm transformations
   mat4 projectionMatrix = perspective(radians((float)fov), asp, dim / 128, dim * 128);
   mat4 viewMatrix = lookAt(cameraPos, cameraPos + cameraFront, cameraUp);

   mat4 modelViewMatrix = translate(viewMatrix, vec3(dx, dy, dz));
   modelViewMatrix = rotate(modelViewMatrix, radians(dps), vec3(0.0, 0.0, 1.0));
   modelViewMatrix = rotate(modelViewMatrix, radians(dth), vec3(0.0, 1.0, 0.0));
   modelViewMatrix = rotate(modelViewMatrix, radians(dph), vec3(1.0, 0.0, 0.0));
   modelViewMatrix = scale(modelViewMatrix, vec3(Scale, Scale, Scale));

   mat3 normalMatrix = inverseTranspose(mat3(modelViewMatrix));

   glBindVertexArray(vao);
   int id;

   if (wireframe)
      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
   else
      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

   if (displayGrid)
   {
      id = glGetUniformLocation(gridProgram, "ProjectionMatrix");
      glUniformMatrix4fv(id, 1, 0, &projectionMatrix[0][0]);
      // id = glGetUniformLocation(shader,"ViewMatrix");
      // glUniformMatrix4fv(id, 1, 0, &viewMatrix[0][0]);
      id = glGetUniformLocation(gridProgram, "ModelViewMatrix");
      glUniformMatrix4fv(id, 1, 0, &modelViewMatrix[0][0]);
      // id = glGetUniformLocation(shader,"NormalMatrix");
      // glUniformMatrix3fv(id, 1, 0, &normalMatrix[0][0]);

      // Set up scalar field on texture unit 1
      // glActiveTexture(GL_TEXTURE1);
      // glBindTexture(GL_TEXTURE_2D, noiseTex);
      // id = glGetUniformLocation(shader, "Scalar3D");
      // glUniform1i(id, 1);

      id = glGetUniformLocation(gridProgram, "isovalue");
      glUniform1f(id, isovalue);

      id = glGetUniformLocation(gridProgram, "cubeStep");
      glUniform1f(id, cubeSize);

      id = glGetUniformLocation(gridProgram, "gridSpace");
      glUniform1f(id, gridSpace);

      id = glGetUniformLocation(gridProgram, "vertexOffsets");
      glUniform3fv(id, 8, vertexOffsets);

      // Draw the marching cubes grid
      glDrawArrays(GL_POINTS, 0, gridSize * gridSize * gridSize);
   }

   glUseProgram(mcProgram);

   //  Set light property uniforms
   id = glGetUniformLocation(mcProgram, "fov");
   glUniform1f(id, fov);
   id = glGetUniformLocation(mcProgram, "Global");
   glUniform4fv(id, 1, global);
   id = glGetUniformLocation(mcProgram, "Ambient");
   glUniform4fv(id, 1, ambient);
   id = glGetUniformLocation(mcProgram, "Diffuse");
   glUniform4fv(id, 1, diffuse);
   id = glGetUniformLocation(mcProgram, "Specular");
   glUniform4fv(id, 1, specular);
   id = glGetUniformLocation(mcProgram, "Position");
   glUniform4fv(id, 1, position);

   id = glGetUniformLocation(mcProgram, "ProjectionMatrix");
   glUniformMatrix4fv(id, 1, 0, &projectionMatrix[0][0]);

   id = glGetUniformLocation(mcProgram, "ViewMatrix");
   glUniformMatrix4fv(id, 1, 0, &viewMatrix[0][0]);

   id = glGetUniformLocation(mcProgram, "ModelViewMatrix");
   glUniformMatrix4fv(id, 1, 0, &modelViewMatrix[0][0]);

   id = glGetUniformLocation(mcProgram, "NormalMatrix");
   glUniformMatrix3fv(id, 1, 0, &normalMatrix[0][0]);

   id = glGetUniformLocation(mcProgram, "surface");
   glUniform1i(id, mode);

   id = glGetUniformLocation(mcProgram, "isovalue");
   glUniform1f(id, isovalue);

   id = glGetUniformLocation(mcProgram, "cubeStep");
   glUniform1f(id, cubeSize);

   id = glGetUniformLocation(mcProgram, "gridSpace");
   glUniform1f(id, gridSpace);

   id = glGetUniformLocation(mcProgram, "vertexOffsets");
   glUniform3fv(id, 8, vertexOffsets);

   glActiveTexture(GL_TEXTURE0);
   glBindTexture(GL_TEXTURE_2D, noiseTex);
   id = glGetUniformLocation(mcProgram, "Scalar3D");
   glUniform1i(id, 0);

   glActiveTexture(GL_TEXTURE1);
   glBindTexture(GL_TEXTURE_2D, mountTex);
   id = glGetUniformLocation(mcProgram, "Tex");
   glUniform1i(id, 1);

   glActiveTexture(GL_TEXTURE2);
   glBindTexture(GL_TEXTURE_2D, edgeTex);
   id = glGetUniformLocation(mcProgram, "EdgeTable");
   glUniform1i(id, 2);

   glActiveTexture(GL_TEXTURE3);
   glBindTexture(GL_TEXTURE_2D, triTex);
   id = glGetUniformLocation(mcProgram, "TriTable");
   glUniform1i(id, 3);

   glDrawArrays(GL_POINTS, 0, gridSize * gridSize * gridSize);

   //  Release attribute arrays
   glBindVertexArray(0);

   //  Fixed pipeline
   glUseProgram(0);

#ifndef APPLE_GL4
   //  Display parameters
   SetColor(1, 1, 1);
   glWindowPos2i(5, 5);
   int fps = FramesPerSecond();
   Print("FPS=%d  Angle=%.2f,%.2f  Dim=%.1f  GridSize=%d  GridSpace=%.1f  Isovalue=%.2f", fps, th, ph, dim, gridSize, gridSpace, isovalue);
#endif
   //  Render the scene and make it visible
   ErrCheck("display");
   glFlush();
   glfwSwapBuffers(window);
}

//
//  Key pressed callback
//
void key(GLFWwindow *window, int key, int scancode, int action, int mods)
{
   //  Discard key releases (keeps PRESS and REPEAT)
   if (action == GLFW_RELEASE)
      return;

   //  Check for shift
   int shift = (mods & GLFW_MOD_SHIFT);

   //  Exit on ESC
   if (key == GLFW_KEY_ESCAPE)
      glfwSetWindowShouldClose(window, 1);
   //  Reset view angle and location
   else if (key == GLFW_KEY_0)
      th = ph = 0;
   //  Change location
   else if (key == GLFW_KEY_X)
      dx += shift ? +0.05 : -0.05;
   else if (key == GLFW_KEY_Y)
      dy += shift ? +0.05 : -0.05;
   else if (key == GLFW_KEY_Z)
      dz += shift ? +0.05 : -0.05;
   //  Change scale
   else if (key == GLFW_KEY_C)
      Scale += shift ? +0.01 : -0.01;
#ifndef APPLE_GL4
   //  Switch surfaces
   else if (key == GLFW_KEY_M)
      mode = (mode + 1) % 3;
   else if (key == GLFW_KEY_N)
   {
      fp = 1 - fp;
      cameraPos = vec3(0.0f, 0.0f, gridSpace / 2);
      cameraFront = vec3(0.0f, 0.0f, -1.0f);
      th = 270.0;
      ph = 0.0;
   }
   else if (key == GLFW_KEY_V)
      axes = 1 - axes;
   else if (key == GLFW_KEY_F)
      wireframe = 1 - wireframe;
#endif
   //  Light movement
   else if (key == GLFW_KEY_L)
      move = 1 - move;
   //  Light movement speed
   else if (key == GLFW_KEY_SEMICOLON)
   {
      ls += shift ? +0.05 : -0.05;
      ls = ls < 0.0 ? 0.0 : ls;
   }
   else if (key == GLFW_KEY_O)
   {
      if (mcProgram == march1)
         mcProgram = march2;
      else
         mcProgram = march1;
   }
   else if (key == GLFW_KEY_I)
   {
      isovalue += shift ? +0.01 : -0.01;
      isovalue = isovalue < -1.0 ? -1.0 : isovalue;
      isovalue = isovalue > 1.0 ? 1.0 : isovalue;
   }
   else if (key == GLFW_KEY_G)
   {
      gridSize += shift ? +1 : -1;
      gridSize = gridSize < 2 ? 2 : gridSize;
      gridSize = gridSize > 50 ? 50 : gridSize;
      initGridVBO(&vbo);
      initGridVAO(&vao, &vbo);
   }
   else if (key == GLFW_KEY_H)
   {
      gridSpace += shift ? +2.0 : -2.0;
      gridSpace = gridSpace < 2.0 ? 2.0 : gridSpace;
      gridSpace = gridSpace > 10.0 ? 10.0 : gridSpace;
      initGridVBO(&vbo);
      initGridVAO(&vao, &vbo);
   }
   else if (key == GLFW_KEY_K)
      displayGrid = 1 - displayGrid;
   //  Increase/decrease asimuth
   else if (key == GLFW_KEY_RIGHT)
      th += 5;
   else if (key == GLFW_KEY_LEFT)
      th -= 5;
   //  Increase/decrease elevation
   else if (key == GLFW_KEY_UP)
      ph += 5;
   else if (key == GLFW_KEY_DOWN)
      ph -= 5;
   //  PageUp key - increase dim
   else if (key == GLFW_KEY_PAGE_DOWN)
      dim += 0.1;
   //  PageDown key - decrease dim
   else if (key == GLFW_KEY_PAGE_UP && dim > 1)
      dim -= 0.1;

   //  Wrap angles
   th = fmod(th, 360);
   ph = fmod(ph, 360);
}

void processMovement(GLFWwindow *window)
{
   const float cameraSpeed = 0.2f * deltaTime;
   if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
      cameraPos += cameraSpeed * cameraFront;
   if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
      cameraPos -= cameraSpeed * cameraFront;
   if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
      cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
   if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
      cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
   if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
      cameraPos += cameraSpeed * cameraUp;
   if (glfwGetKey(window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS)
      cameraPos -= cameraSpeed * cameraUp;
}

void mouse_callback(GLFWwindow *window, double xpos, double ypos)
{
   if (firstMouse)
   {
      lastX = xpos;
      lastY = ypos;
      firstMouse = false;
   }

   float xoffset = xpos - lastX;
   float yoffset = lastY - ypos;
   lastX = xpos;
   lastY = ypos;

   float sensitivity = 0.05f;
   xoffset *= sensitivity;
   yoffset *= sensitivity;

   th += xoffset;
   ph += yoffset;

   if (ph > 89.0f)
      ph = 89.0f;
   if (ph < -89.0f)
      ph = -89.0f;

   //  Wrap angles
   th = fmod(th, 360);
   ph = fmod(ph, 360);

   vec3 direction;
   direction.x = cos(radians(th)) * cos(radians(ph));
   direction.y = sin(radians(ph));
   direction.z = sin(radians(th)) * cos(radians(ph));
   cameraFront = normalize(direction);
   cameraUp.y = cos(radians(ph));
}

void enableBlending()
{
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
}

//
//  Window resized callback
//
void reshape(GLFWwindow *window, int width, int height)
{
   //  Get framebuffer dimensions (makes Apple work right)
   glfwGetFramebufferSize(window, &width, &height);
   //  Ratio of the width to the height of the window
   asp = (height > 0) ? (double)width / height : 1;
   //  Set the viewport to the entire window
   glViewport(0, 0, width, height);
}

//
//  Main program with GLFW event loop
//
int main(int argc, char *argv[])
{
   //  Initialize GLFW
   GLFWwindow *window = InitWindow("Noah James", 1, 1600, 1200, &reshape, &key);

   // Configuration and callbacks
   glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
   glfwSetCursorPosCallback(window, mouse_callback);

   // Load shaders (grid shader, no texture marching cubes, textured marching cubes)
   gridProgram = CreateShaderProgGeom("march.vert", "march4.geom", "march4.frag");
   march1 = CreateShaderProgGeom("march.vert", "march.geom", "march.frag");
   march2 = CreateShaderProgGeom("march.vert", "march2.geom", "march2.frag");
   mcProgram = march1;

   // Setting direction that camera is initially pointing
   cameraPos = vec3(0.0f, 0.0f, 8.0f);
   cameraFront = vec3(0.0f, 0.0f, -1.0f);
   cameraUp = vec3(0.0f, cos(radians(ph)), 0.0f);

   // Load texture data (noise, image, edge table, triangle table)
   noiseTex = CreateNoise3D(GL_TEXTURE0);
   glActiveTexture(GL_TEXTURE1);
   mountTex = LoadTexBMP("rock_mountain.bmp");
   loadEdgeTable(&edgeTex, GL_TEXTURE2);
   loadTriTable(&triTex, GL_TEXTURE3);

   // Initialize grid buffer and VAO
   initGridVBO(&vbo);
   initGridVAO(&vao, &vbo);

   // Enable blending for grid
   enableBlending();

   // Event loop
   ErrCheck("init");
   while (!glfwWindowShouldClose(window))
   {
      //  Light animation
      if (move)
      {
         zh = fmod(glfwGetTime() * ls, 360);
      }
      float currentFrame = glfwGetTime();
      deltaTime = currentFrame - lastFrame;
      lastFrame = currentFrame;

      processMovement(window);

      //  Display
      display(window);
      //  Process any events
      glfwPollEvents();
   }
   //  Shut down GLFW
   glfwDestroyWindow(window);
   glfwTerminate();
   return 0;
}
